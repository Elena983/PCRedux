---
title: "PCRedux package - an overview"
author: "Stefan R&ouml;diger, Micha&#322; Burdukiewicz, Andrej-Nikolai Spiess"
date: "2017-09-15"
output: 
  rmarkdown::html_vignette:
    toc: true
bibliography: "PCRedux.bib"
vignette: >
  %\VignetteIndexEntry{PCRedux package - an overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Introduction to the analysis of simgmoid shaped curves â€“ or the analysis of amplification curve data from quantitative real-time PCR experiments

**PCRedux** is an R package designed to perform analysis of sigmoid curves. A 
sigmoid function results a S-shaped curve. For example, the equation 
\autoref{sigmoid} produces such curvature.

\begin{equation}
\label{sigmoid}
f(x) = \frac{1}{1 +  e^{-x}}
\end{equation}

These non-linar functions are real-valued and can be differentiated (first derivative 
maximum, with one local minimum and one loacl maximum).

This 
kind of curve is common in many biological assays such as quantitative 
real-time 
PCR (qPCR) experiments. qPCRs are performed in thermo-cyclers. There are many 
manufactures of such systems, which offer such technologies as commercial 
products. Moreover, thermo-cyclers are produced in house as part of scientific 
projects. An example is the VideoScan-technology [@rodiger_highly_2013].

A challenge for the user is, to make sense from the data produced by these 
devices. This is a manageable task if the volume of data is low, or dedicated 
software is available for the analysis thereof. An example for a low number of 
amplification curves is shown in Figure \ref{samples_of_qPCRs}A. All `r 
ncol(chipPCR::C127EGHP)-1` curves exhibit a sigmoid curve shape. In contrast, 
the example in Figure \ref{samples_of_qPCRs}B is no longer manageable by simple 
visual inspection. The data originate from a high-throughput experiment an 
encompass in total `r ncol(qpcR::htPCR)-1` amplification curves. Similarly, a 
manual analysis of the data is time-consuming and prone to errors. Dedicated 
software that can distinguish the amplification curves automatically is needed.


```{r, echo=FALSE, fig.cap="Sample data from A) the **C127EGHP** data set with 64 amplification curves (*chipPCR* package, [@rodiger_chippcr:_2015]) and B) from the **htPCR** data set with 8858 amplification curves (*qpcR* package, [@ritz_qpcr:_2008]). \\label{samples_of_qPCRs}", fig.height=7, fig.width=7}
    
library(chipPCR)
suppressMessages(library(qpcR))


par(mfrow=c(1,2), las=0, bty="n", oma=c(1,1,1,1))
colors <- rainbow(ncol(C127EGHP)-2, alpha=0.3)
matplot(C127EGHP[, 2], C127EGHP[, c(-1, -2)], xlab="Cycle", ylab="RFU", 
        main="C127EGHP dataset", type="l", lty=1, lwd=2, col=colors)
mtext("A", cex = 2, side = 3, adj = 0, font = 2)

colors <- rainbow(ncol(htPCR)-1, alpha=0.2)
matplot(htPCR[, 1], htPCR[, c(-1)], xlab="Cycle", ylab="RFU", 
        main="htPCR dataset", type="l", lty=1, lwd=2, col=colors)
mtext("B", cex = 2, side = 3, adj = 0, font = 2)
```

There are several open source and closed source software tools, which can be 
used 
for the analysis of qPCR data. The software packages deal for example with
    
    * missing values, 
    * noise,
    * inter run calibration, 
    * normalization, 
    * quantification cycle estimation, 
    * amplification efficiency estimation, 
    * data import, 
    * datat export, 
    * data exchange, 
    * realative gene expression analysis,
    
and other tasks [@pabinger_survey_2014, @rodiger_chippcr:_2015, 
@ritz_qpcr:_2008, @rodiger_r_2015, @lefever_rdml:_2009, 
@ruijter_rdml-ninja_2015, @rodiger_enabling_2017, @perkins_readqpcr_2012, 
@pabinger_qpcr:_2009, @neve_unifiedwmwqpcr:_2014, @feuer_lemming:_2015, 
@mccall_non-detects_2014, @ruijter_evaluation_2013, @ruijter_removal_2015, 
@dvinge_htqpcr:_2009, @ronde_practical_2017, @mallona_pcrefficiency:_2011, 
@mallona_chainy:_nodate]. Many of them are implemented in the R statistical 
computing language. It should be mentioned that this list is far from 
completeness. Dedicated literature is available from peer-reviewed publications 
and textbooks.

Others and we have shown that amplification curve analysis is not a simple 
task. For example selected qPCR systems (device and/or detection chemistry) 
cause periodicity in the amplification curve data 
[@spiess_system-specific_2016]. Or the commonly employed smoothing of data 
might 
case alterations to the raw data that affects both the estimation of the 
template material (Cq value) and the amplification efficiency 
[@spiess_impact_2015].

At this level all software assumes that the amplification resemble a sigmoid 
curve shape (ideal positive amplification reaction) or a flat low line (ideal 
negative amplification reaction). For example, @ritz_qpcr:_2008 published an R 
package that contains functions to fit several multi-parameter models. This 
includes the 5-parameter Richardson function, which is often used for the 
analysis of qPCR data.

In general, the software packages do not take into account if an amplification 
curve fulfills a certain criterion (e.g., positive or negative, good quality or 
bad quality). This is a needed information for some algorithms. For example, 
the 
*linreg* method by @ruijter_amplification_2009 requires a decision, if an 
amplification curve is positive or negative. 

To illistrate this problem we give and example for the analysis of amplification 
curves of the ``htPCR`` data set in the section about the function 
`decision_modus`.

In summary, during our past research we noticed that a many challenges are well 
addressed. In particular, algorithms for the processing of the positive 
amplification curves are widely available. One bottleneck in qPCR data 
analysis is the lack of amplification curve data classifier. Classifier herein 
refer to a vector of features that can be used to distinguish the amplification 
curves by their shape only.

One reason for this is the lack of features that are known for amplification 
curve data. Only few features for amplification curves are described in the 
literature. For example, tools described by us are the ``amptester`` and the 
``amptester.gui`` functions, which are part of the **chipPCR** package 
([@rodiger_chippcr:_2015]). The **qpcR** package ([@ritz_qpcr:_2008]) contains 
an amplification curve test via the ``modlist`` function. The parameter check = 
"uni2" offers an analytical approach, as part of a method for the kinetic 
outlier detection. It checks for a sigmoid structure of the amplification curve. 
Then it tests for the location of the first derivative maximum and the second 
derivative maximum. However, multi-parameter functions, like sigmoid models, fit 
"successful" in most cases including noise and give false positive results. 

# Aim of the `PCRedux` package

The `PCRedux` package contains function and data sets for machine learning on 
quantitative PCR data in R. There are numerous software packages for R which 
can 
be used for the analysis of quantitative PCR (qPCR) data [@rodiger_r_2015, 
@pabinger_survey_2014].

This vignette covers important features of the package and should be used as an 
addendum to the manual.

Reproducible research is an important foundation of research. Both, the technical 
and the experimental aspects need to be performed under principles that follow 
good practice of reproducible research. Several authors addressed the matter 
[@huggett_how_2014, @bustin_reproducibility_2014, @bustin_continuing_2017, 
@rodiger_r_2015, @rodiger_enabling_2017, @wilson_good_2016]. During our 
literature studies we found barely material, which can be used for further 
studies. Therefore, we included data set of amplification curves, human rated 
amplification curves (negative, ambiguous, positive) and examples in this 
package.

# Functions of the `PCRedux` package

The function described following are aimed for experimental studies. It is 
important to note that the features proposed herein emerged during a critical 
reasoning process. The aim of the package is to propose a set of features, 
functions and data for an independent research.

## autocorrelation_test - A function to detect positive amplification curves

Autocorrelation analysis is a technique that is used in the field of time series 
analysis. It can be used to reveal regularly occurring patterns in 
one-dimensional data [@spiess_system-specific_2016]. The autocorrelation 
function measures the correlation of a signal $f(t)$ with itself shifted by some 
time delay $f(t - \tau)$.

The `autocorrelation_test` function coercers the amplification curve data to an 
object of the class "zoo" (*zoo* package) as indexed totally ordered 
observations. Next follows the computation of a lagged version of the 
amplification curve data. The shifting the amplification curve data is based 
back by a given number of observations (default $\tau = 3$). Then follows a 
significance test for correlation between paired samples (amplification curve 
data & lagged amplification curve data). The hypothesis is that the paired 
sample of positive amplification curves has a significant correlation 
(`stats::cor.test`, significance level is 0.01) in contrast to negative 
amplification curves (noise).
The application of the `autocorrelation_test` function is shown in the following 
example. 

```{r, echo=TRUE, fig.cap="Autocorrelation analysis for amplification curves of the **testdat** data set (*qpcR* package, [@ritz_qpcr:_2008]). A) All amplification curves of the **testdat** data set. B) Positive curves (1) and negative (0) curves as determined by the `autocorrelation_test`. C) Positive curves (1) and negative (0) curves as determined by a human. \\label{autocorrelation}", fig.height=6, fig.width=8}
# Test for autocorrelation in amplification curve data
# Load the libraries magrittr for pipes and qpcR for the data
library(magrittr)
library(PCRedux)
library(qpcR)

# Test for an autocorrelation in the testdat dataset
res_ac <- sapply(2:ncol(testdat), function(i) {
    autocorrelation_test(testdat[, i])
}
)

# Plot curve data as overview
# Define the colors for the amplification curves
colors <- rainbow(ncol(testdat)-1, alpha=0.3)
# Names of samples
samples <- colnames(testdat)[-1]
layout(matrix(c(1,2,1,3), 2, 2, byrow = TRUE))
matplot(testdat[, 1], testdat[, -1], xlab="Cycle", ylab="RFU", 
        main="testdat dataset", type="l", lty=1, col=colors, lwd=2)
legend("topleft", samples, pch=19, col=colors, ncol=2, bty="n")
mtext("A", cex = 2, side = 3, adj = 0, font = 2)

# Curves rated by a human after analysis of the overview. 1 = positive, 
# 0 = negative
human_rating <- c(1,1,0,0,1,1,0,0,
                  1,1,0,0,1,1,0,0,
                  1,1,0,0,1,1,0,0)

# Convert the n.s. (not significant) in 0 and others to 1. 
# Combine the results of the automatic autocorrelation_test as variable "ac", 
# the human rated values as variable "hr" in a new data frame (res_ac_hr).
res_ac_hr <- data.frame(ac=ifelse(res_ac=="n.s.", 0, 1), 
                        hr=human_rating) %>% as.matrix
                        
# Add ratings by human and autocorrelation_test to the plot
par(las=2)
barplot(res_ac_hr[, "ac"], main="Rated by autocorrelation_test", col=colors, 
        xlab="Sample", ylab="rating", names.arg=samples)
mtext("B", cex = 2, side = 3, adj = 0, font = 2, las=1)

barplot(res_ac_hr[, "hr"], main="Rated by a human", col=colors, xlab="Sample", 
        ylab="rating", names.arg=samples)
mtext("C", cex = 2, side = 3, adj = 0, font = 2, las=1)
```

As shown in this example, the `autocorrelation_test` function is able to 
distinguish between positive and negative amplification curves. Negative 
amplification curve were in all cases non-significant. In contrast, the 
coefficients of correlation for positive amplification curves ranged between `r 
signif(range(as.numeric(res_ac), na.rm=TRUE), 3)[1]` and `r 
signif(range(as.numeric(res_ac), na.rm=TRUE), 3)[2]` at a significance level of 
0.01 and a lag of 3.

## decision_modus - A function to get a decision (modus) from a vector of classes

Several approaches for machine learning exist. One of them is the supervised 
learning, where the aim is to infer a function from labeled training data. 
Labeled training data are for example created by a human. As described in the 
sections before, amplification curves can be labeled as negative, ambiguous or 
positive for example (Figure \ref{htPCR_nap}) were taken from the ``htPCR`` 
dataset (compare Figure \ref{samples_of_qPCRs}B).


```{r, echo=FALSE, fig.cap="Sample data from the **htPCR** data set (*qpcR* package, [@ritz_qpcr:_2008]) with negative (black), ambiguous (red) or positive (green) amplification curves. The negative amplification curve has no sigmoid curvature, just a strong positive trend. The ambiguous amplification curve is not a perfect sigmoid curve, exhibits a positive slope in the background phase (cylce 1 $\rightarrow$ 5) and a low amplitude. In contrast, the positive amplification curve has a sigmoid curvature, starting with a background phase (cylce 1 $\rightarrow$ 5), an exponential phase (cylce 6 $\rightarrow$ 25) and a plateau phase (cylce 26 $\rightarrow$ 35). \\label{htPCR_nap}", fig.height=4, fig.width=7}
library(qpcR)
matplot(htPCR[, 1], htPCR[, c(552, 512, 616)], xlab="Cycle", ylab="RFU", main="htPCR dataset", type="l", lty=1, lwd=2)
legend("topleft", c(paste("negative ", colnames(htPCR)[552]), 
                    paste("ambiguos ", colnames(htPCR)[512]), 
                    paste("positive ", colnames(htPCR)[616])
                   ), col=1:3, pch=19, bty="n")
```

Provided that different users are given the task to rate the amplification 
curves, it is likely that the ambiguous amplification curve (`r 
colnames(htPCR)[512]`) in Figure \ref{htPCR_nap} will get another rating 
(ambiguos $\rightarrow$ positive) from an inexperienced user. We performed 
exactly this kind of experiment with different users. For this task the 
amplification curve data were analyzed as described in @rodiger_chippcr:_2015 
(supplementary information).

The following table gives the first five and the last five rows for the rating 
of the amplification curves for the ``htPCR`` data set (in total `r 
ncol(qpcR::htPCR)-1` amplification curves). All curves were rated randomly three 
times. All raw data a contained in the CSV file `decision_res_htPCR.csv` as 
part of the ``PCRedux`` package.

```{r, eval=TRUE, echo=TRUE}
library(PCRedux)
library(data.table)
library(magrittr)
filename <- system.file("decision_res_htPCR.csv", package = "PCRedux")
decision_res_htPCR <- as.data.frame(fread(filename))
head(decision_res_htPCR)
tail(decision_res_htPCR)
```

As seen in the example the rating for the same amplification curves vary (e.g., 
row 1 "P01.W01"), while others are in agreement (e.g., row 8856 "P95.W94"). 
``decision_modus`` is a function that can be used to find the most frequent 
(modus) decision in such a data set. The classes were defined by the user 
(e.g., "a", "n", "y" -> "ambiguous", "negative", "positive"). This function is 
useful if large collections of varying decision (e.g., "a", "a", "a", "n", 
"n") need to be condensed to a single decision (3 x "a", 2 x "n" $\rightarrow$ 
"a").

We used the ``decision_modus`` function on the `decision_res_htPCR.csv` data 
set (see with all the ratings (column 2 to 4) and determined the modus of each 
line.

```{r, eval=TRUE, echo=TRUE}
# Use decision_modus to go rowise through all human ratings

dec <- lapply(1L:nrow(decision_res_htPCR), function(i) {
decision_modus(decision_res_htPCR[i, 2:4])
}) %>% unlist

names(dec) <- decision_res_htPCR[, 1]

# Show statistic of the decisions
summary(dec)
```

```{r, echo=FALSE, fig.cap="Summary of all sample data from the **htPCR** data set (*qpcR* package, [@ritz_qpcr:_2008]) with negative (black), ambiguous (red) or positive (green) amplification curves. \\label{htPCR_nap}", fig.height=4, fig.width=7}

# Plot the Frequencies of the decisions
barplot(table(dec), xlab="Decision", ylab="Frequency", main="Amplification curves rated by humans\n htPCR data set", col=c(2,3,1))
```

Another usage of the ``decision_modus`` function is by setting the `max_freq` 
parameter to `FALSE`. This option gives the counts of all decisions.

```{r, eval=TRUE, echo=TRUE}
# Decisions for sample P01.W06
decision_modus(decision_res_htPCR[which(decision_res_htPCR[["sample"]] == "P01.W06"), 2:4], max_freq=FALSE)

# Decisions for sample P01.W13
decision_modus(decision_res_htPCR[which(decision_res_htPCR[["sample"]] == "P01.W13"), 2:4], max_freq=FALSE)
```


```{r, eval=TRUE, echo=TRUE}
# Load the human rated data sets decision_res_htPCR.csv and the reevaluation 
# decision_res_htPCR_reevaluation.csv thereof.
# Load the decision_res_htPCR.csv data set
filename <- system.file("decision_res_htPCR.csv", package = "PCRedux")
decision_res_htPCR <- as.data.frame(fread(filename))

# Load the decision_res_htPCR_reevaluation.csv data set
filename <- system.file("decision_res_htPCR_reevaluation.csv", package = "PCRedux")
decision_res_htPCR_reevaluation <- as.data.frame(fread(filename))

# Show the first five elements of both data sets
head(decision_res_htPCR)
head(decision_res_htPCR_reevaluation)

# Renanme the columns to give them the same pattern
pattern <- c("sample", "test.result.1", "test.result.2", "test.result.3", "conformity")
colnames(decision_res_htPCR_reevaluation) <- pattern
colnames(decision_res_htPCR) <- pattern

# Merge the two data sets based on the sample name (amplification curve).
decision_res_htPCR_merged <- merge(decision_res_htPCR[, -5], 
                                   decision_res_htPCR_reevaluation[, -5], 
                                   by="sample")

# Show the first five elements of the merged data sets
head(decision_res_htPCR_merged)

#------------------

par(mfrow=c(1,3))

data <- decision_res_htPCR_merged

decision_plot <- function(data, name="", rating_columns=2:4){
    dec <- lapply(1L:nrow(data), function(i) {
        decision_modus(data[i, c(rating_columns)])
    }) %>% unlist
    barplot(table(dec), xlab="Decision", ylab="Frequency", main=paste("Amplification curves rated by humans\n htPCR data set", name), col=c(2,3,1))
}

par(mfrow=c(1,3))

decision_plot(decision_res_htPCR, name="", rating_columns=2:4)
decision_plot(decision_res_htPCR_reevaluation, name="", rating_columns=2:4)
decision_plot(decision_res_htPCR_merged, name="merged", rating_columns=2:7)

```

## earlyreg - A function to calculate the slope and intercept of an amplification curve data from a quantitative PCR experiment

There are numerous segments of an amplification curve, that are potentially 
useful to extract a feature for an amplification curve classification. In Figure 
\ref{earlyreg_slopes} are the first 500 amplification curves from the ``htPCR`` 
data set shown. Besides the fact that the data stem from a high-throughput 
experiment they exhibit interesting characteristics. Some of the amplification 
curves obviously deviate from the curvature as expected from a sigmoid model. In 
particular, some of the amplification curve just have a positive (linear) trend 
without typical infliction points. Others show a step signal increase even in the 
background phase (cycle 1 to 10) (compare @rodiger_chippcr:_2015, Figure S12). 
The slope and the intercept in background region is an interesting target for a 
classification.

We suggest using the slope and the intercept for the differentiation of the 
different amplification curves. Therefore, we developed the function 
``earlyreg``. This wrapper function uses a MM-type estimator for a robust linear 
regression [@todorov_object-oriented_2009]. ``earlyreg`` ignores the first cycle 
value and includes by default the next six cycle-dependent amplitude values to 
perform the regression on them. For the analysis we used arbitrarily the first 
500 
amplification curves of the ``htPCR`` dataset.

The following example illustrates a potential use of the ``earlyreg`` function 
on the **htPCR** data set. Figure \ref{earlyreg_slopes}A shows all amplification 
curves. Figure \ref{earlyreg_slopes}B shows only the first ten cycles.

```{r, echo=TRUE, fig.cap="Amplification curves from the **htPCR** data set (*qpcR* package). The amplification curves show different slopes in the early phase (cycle 1 to 10) of the qPCR. \\label{earlyreg_slopes}", fig.height=4, fig.width=7}
par(bty="n", font=2, font.axis=2, las=1, cex.axis=1.3, cex.lab=1.3, lwd=1.3, bg="white", oma=c(.5,.5,.5,.5))
data <- htPCR[, 1:501]
curve_colors <- c(rainbow(ncol(data)-1, alpha=.5))
range <- 1:10

par(mfrow=c(1,2), las=0, bty="n", oma=c(1,1,1,1))

matplot(data[, 1], data[, -1], col= curve_colors, pch=19, lty=1, type="l", 
        xlab="Cycle", ylab="RFU", main="htPCR dataset")
mtext("A", cex = 2, side = 3, adj = 0, font = 2)

matplot(data[range, 1], data[range, -1], col= curve_colors, pch=19, lty=1, 
        type="l", xlab="Cycle", ylab="RFU", 
        main="htPCR dataset\n Cycle 1 to 10")
mtext("B", cex = 2, side = 3, adj = 0, font = 2)
```
Next we calculated of the slope and intercept with the ``earlyreg`` function 
for 
the first six cycles of the qPCR data. The results were subjected to a cluster 
analysis by k-means clustering. For the analysis we focused on the slope, 
because the intercept is representing the background fluorescence in the early 
phase of the qPCR. As shown in figure \ref{earlyreg_results}B exhibited the 
density function of all intercept values a mono-modal shaped bell curve. In 
contrast, the density function of all slope values had a bi-modal shaped bell 
curve (figure \ref{earlyreg_results}C). Therefore, the slope appears to be an 
indicator for differences between the qPCR amplification curves.

The cluster analysis by k-means (k=3, assumed weak slope, moderate slope, strong 
slope) on the slope data was plotted. The clusters grouped the amplification 
curve data in curves with no-background region and high slope, amplification 
curves with no-background region and a weaker slope and amplification curves 
with background region and a weak slope (figure \ref{earlyreg_results}D-F).

To conclude, this approach might be of use for the classification of 
amplification curves.

```{r, echo=TRUE, fig.cap="\\label{earlyreg_results}Clusters of samples according to their slope and intercept. The **htPCR** data set (*qpcR* package) was used. The amplification curves show different slopes in the early phase (cycle 1 to 10) of the qPCR. Both the slope and the intercept were used for a cluster analysis (k-means).", fig.height=7, fig.width=7}
# Normalize each amplification curve to their 0.99 quantile and use the 
# earlyreg function to determine the slope and intercept of the first 
# 6 cycles

res_slope_intercept <- do.call(rbind, lapply(2L:ncol(data), function(i){
                     earlyreg(x=data[, 1], y=data[, i], range=7, normalize=TRUE)
                    }))
# Label the sample with their original names
rownames(res_slope_intercept) <- colnames(htPCR)[2:ncol(data)]
# Use k-means for cluster analysis
res_kmeans <- kmeans(res_slope_intercept[, "slope"], 3)$"cluster"

par(mfrow=c(2,3))
plot(res_slope_intercept, col=res_kmeans)
mtext("A", cex = 2, side = 3, adj = 0, font = 2)

plot(density(res_slope_intercept[, "intercept"]), main="Intercept")
mtext("B", cex = 2, side = 3, adj = 0, font = 2)

plot(density(res_slope_intercept[, "slope"]), main="Slope")

for(i in unique(res_kmeans)) {
    abline(v=min(res_slope_intercept[res_kmeans==i, "slope"]), col=i)
}
mtext("C", cex = 2, side = 3, adj = 0, font = 2)

matplot(data[, 1], data[, which(res_kmeans==1)+1], col= curve_colors, pch=19, lty=1, 
 type="l", xlab="Cycle", ylab="RFU", 
 main="htPCR dataset (1-500)\n Cluster 1", ylim=c(min(data[, -1]), 0.4))
mtext("D", cex = 2, side = 3, adj = 0, font = 2)

matplot(data[, 1], data[, which(res_kmeans==2)+1], col= curve_colors, pch=19, lty=1, 
 type="l", xlab="Cycle", ylab="RFU", 
 main="htPCR dataset (1-500)\n Cluster 2", ylim=c(min(data[, -1]), 0.4))
mtext("E", cex = 2, side = 3, adj = 0, font = 2)

matplot(data[, 1], data[, which(res_kmeans==3)+1], col= curve_colors, pch=19, lty=1, 
 type="l", xlab="Cycle", ylab="RFU", 
 main="htPCR dataset (1-500)\n Cluster 3", ylim=c(min(data[, -1]), 0.4))
mtext("F", cex = 2, side = 3, adj = 0, font = 2)
```

## head2tailratio - A function to calculate the ratio of the head and the tail of a quantitative PCR amplification curve


The ``head2tailratio`` function calculates the ratio of the head and the tail of 
a quantitative PCR amplification curve. The begin of the amplification curve 
(head, background region) and the end of the amplification curve (tail, plateau 
region) are in positive amplification. Therefore, these segments are potentially 
useful to extract a feature for an amplification curve classification.

## hookreg and hookregNL



## mblrr - A function perform the Quantile-filter based Local Robust Regression

```{r, echo=TRUE, fig.cap="\\label{earlyreg_mblrr}Some text here.", fig.height=7, fig.width=7}
library(qpcR)
par(mfrow=c(2,2))
data <- htPCR[, c(1, 20:30, 500:510, 6000:6020, 8000:8020)]
for(i in 2:ncol(data)){
        x <- data[, 1]
        y_tmp <- data[, i]/quantile(data[, i], 0.999)
        res_q25 <- y_tmp < quantile(y_tmp, 0.25)
        res_q75 <- y_tmp > quantile(y_tmp, 0.75)
        res_q25_lm <- try(suppressWarnings(lmrob(y_tmp[res_q25] ~ x[res_q25])), silent=TRUE)
        res_q75_lm <- try(suppressWarnings(lmrob(y_tmp[res_q75] ~ x[res_q75])), silent=TRUE)
        
        plot(x, y_tmp, xlab="Cylce", ylab="RFU (normalized)", main=colnames(data)[i], type="b", pch=19)
        abline(res_q25_lm, col="red")
        points(x[res_q25], y_tmp[res_q25], cex=2.5, col="red")
        abline(res_q75_lm, col="green")
        points(x[res_q75], y_tmp[res_q75], cex=2.5, col="green")
    }
```

```{r, eval=TRUE, echo=TRUE}
res_mblrr <- do.call(cbind, lapply(2L:ncol(testdat), function(i) {
                mblrr(x=testdat[, 1], y=testdat[, i], normalize=TRUE) %>% data.frame
}))
colnames(res_mblrr) <- colnames(testdat)[-1]

a <- res_mblrr %>% t
```

## pcrfit_helper

## pcrfit_parallel

## qPCR2fdata


# Summary and conclusions

The `PCRedux` enables the user to extract features from amplification curve 
data. We implemented numerous features that can be extracted from the 
amplification curve data. Some of them have not been described in the 
literature. We consider `PCRedux` as enabling technology for further research. 
For example, the proposed features can be used for machine learning applications 
or quality assessment of data.

The ``pcrfit_helper`` function is a wrapper that can be extended if new features 
emerge.

Of note, we would like to emphasis that the functionality of this package is not 
limited to amplification curve data from qPCR experiments. As stated before, 
amplification curves have a sigmoid curve shape. So do many other processes. 

# References
